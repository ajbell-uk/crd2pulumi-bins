"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Parameter = void 0;
const reflect = __importStar(require("jsii-reflect"));
const schema_1 = require("../schema");
class Parameter {
    constructor(transpile, parameter) {
        this.transpile = transpile;
        this.parameter = parameter;
        this.transpiledParam = transpile.parameter(parameter);
        this.transpiledCallable = transpile.callable(parameter.method);
    }
    toJson() {
        var _a;
        let typeschema = this.transpiledParam.typeReference.toJson();
        // If the parameter is variadic, then we have to change the formatting pattern of the type schema.
        // For example, if the formatting pattern for a string type is 'string', we'd make it variadic by
        // changing it to '...string[]' in Typescript - each language has its own variadic syntax which is defined
        // in the `variadicOf()` function.
        //
        // Another example: let's say we have a Python function that takes a single number parameter like so: 'number: int'
        // To make this variadic, we'd change it to '*number: int' -- here, the formatting pattern needs to be updated to prepend
        // the '*' character to indicate the parameter is variadic.
        if (this.transpiledParam.variadic) {
            typeschema = {
                formattingPattern: this.transpile.variadicOf(typeschema.formattingPattern),
                types: typeschema.types,
            };
        }
        const isInitializer = this.parameter.method.kind === reflect.MemberKind.Initializer;
        const methodName = isInitializer ? 'Initializer' : this.transpiledCallable.name;
        const methodId = isInitializer ? 'Initializer' : this.parameter.method.name;
        return {
            fqn: `${this.transpiledParam.parentType.fqn}.${methodName}.parameter.${this.transpiledParam.name}`,
            displayName: this.transpiledParam.name,
            id: `${this.parameter.parentType.fqn}.${methodId}.parameter.${this.parameter.name}`,
            optional: this.transpiledParam.optional === true ? true : undefined, // to save space
            default: (_a = this.parameter.spec.docs) === null || _a === void 0 ? void 0 : _a.default,
            type: typeschema,
            variadic: this.transpiledParam.variadic,
            docs: (0, schema_1.extractDocs)(this.parameter.docs),
        };
    }
}
exports.Parameter = Parameter;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFyYW1ldGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2RvY2dlbi92aWV3L3BhcmFtZXRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxzREFBd0M7QUFDeEMsc0NBQXlEO0FBR3pELE1BQWEsU0FBUztJQUdwQixZQUNtQixTQUFvQixFQUNwQixTQUE0QjtRQUQ1QixjQUFTLEdBQVQsU0FBUyxDQUFXO1FBQ3BCLGNBQVMsR0FBVCxTQUFTLENBQW1CO1FBRTdDLElBQUksQ0FBQyxlQUFlLEdBQUcsU0FBUyxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUN0RCxJQUFJLENBQUMsa0JBQWtCLEdBQUcsU0FBUyxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDakUsQ0FBQztJQUVNLE1BQU07O1FBQ1gsSUFBSSxVQUFVLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxhQUFhLENBQUMsTUFBTSxFQUFFLENBQUM7UUFDN0Qsa0dBQWtHO1FBQ2xHLGlHQUFpRztRQUNqRywwR0FBMEc7UUFDMUcsa0NBQWtDO1FBQ2xDLEVBQUU7UUFDRixtSEFBbUg7UUFDbkgseUhBQXlIO1FBQ3pILDJEQUEyRDtRQUMzRCxJQUFJLElBQUksQ0FBQyxlQUFlLENBQUMsUUFBUSxFQUFFLENBQUM7WUFDbEMsVUFBVSxHQUFHO2dCQUNYLGlCQUFpQixFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxpQkFBaUIsQ0FBQztnQkFDMUUsS0FBSyxFQUFFLFVBQVUsQ0FBQyxLQUFLO2FBQ3hCLENBQUM7UUFDSixDQUFDO1FBQ0QsTUFBTSxhQUFhLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsSUFBSSxLQUFLLE9BQU8sQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDO1FBQ3BGLE1BQU0sVUFBVSxHQUFHLGFBQWEsQ0FBQyxDQUFDLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsSUFBSSxDQUFDO1FBQ2hGLE1BQU0sUUFBUSxHQUFHLGFBQWEsQ0FBQyxDQUFDLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUM7UUFDNUUsT0FBTztZQUNMLEdBQUcsRUFBRSxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUMsVUFBVSxDQUFDLEdBQUcsSUFBSSxVQUFVLGNBQWMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLEVBQUU7WUFDbEcsV0FBVyxFQUFFLElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSTtZQUN0QyxFQUFFLEVBQUUsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBQyxHQUFHLElBQUksUUFBUSxjQUFjLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFO1lBQ25GLFFBQVEsRUFBRSxJQUFJLENBQUMsZUFBZSxDQUFDLFFBQVEsS0FBSyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsU0FBUyxFQUFFLGdCQUFnQjtZQUNyRixPQUFPLEVBQUUsTUFBQSxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLDBDQUFFLE9BQU87WUFDMUMsSUFBSSxFQUFFLFVBQVU7WUFDaEIsUUFBUSxFQUFFLElBQUksQ0FBQyxlQUFlLENBQUMsUUFBUTtZQUN2QyxJQUFJLEVBQUUsSUFBQSxvQkFBVyxFQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDO1NBQ3ZDLENBQUM7SUFDSixDQUFDO0NBQ0Y7QUF6Q0QsOEJBeUNDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgcmVmbGVjdCBmcm9tICdqc2lpLXJlZmxlY3QnO1xuaW1wb3J0IHsgZXh0cmFjdERvY3MsIFBhcmFtZXRlclNjaGVtYSB9IGZyb20gJy4uL3NjaGVtYSc7XG5pbXBvcnQgeyBUcmFuc3BpbGUsIFRyYW5zcGlsZWRDYWxsYWJsZSwgVHJhbnNwaWxlZFBhcmFtZXRlciB9IGZyb20gJy4uL3RyYW5zcGlsZS90cmFuc3BpbGUnO1xuXG5leHBvcnQgY2xhc3MgUGFyYW1ldGVyIHtcbiAgcHJpdmF0ZSByZWFkb25seSB0cmFuc3BpbGVkUGFyYW06IFRyYW5zcGlsZWRQYXJhbWV0ZXI7XG4gIHByaXZhdGUgcmVhZG9ubHkgdHJhbnNwaWxlZENhbGxhYmxlOiBUcmFuc3BpbGVkQ2FsbGFibGU7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgdHJhbnNwaWxlOiBUcmFuc3BpbGUsXG4gICAgcHJpdmF0ZSByZWFkb25seSBwYXJhbWV0ZXI6IHJlZmxlY3QuUGFyYW1ldGVyLFxuICApIHtcbiAgICB0aGlzLnRyYW5zcGlsZWRQYXJhbSA9IHRyYW5zcGlsZS5wYXJhbWV0ZXIocGFyYW1ldGVyKTtcbiAgICB0aGlzLnRyYW5zcGlsZWRDYWxsYWJsZSA9IHRyYW5zcGlsZS5jYWxsYWJsZShwYXJhbWV0ZXIubWV0aG9kKTtcbiAgfVxuXG4gIHB1YmxpYyB0b0pzb24oKTogUGFyYW1ldGVyU2NoZW1hIHtcbiAgICBsZXQgdHlwZXNjaGVtYSA9IHRoaXMudHJhbnNwaWxlZFBhcmFtLnR5cGVSZWZlcmVuY2UudG9Kc29uKCk7XG4gICAgLy8gSWYgdGhlIHBhcmFtZXRlciBpcyB2YXJpYWRpYywgdGhlbiB3ZSBoYXZlIHRvIGNoYW5nZSB0aGUgZm9ybWF0dGluZyBwYXR0ZXJuIG9mIHRoZSB0eXBlIHNjaGVtYS5cbiAgICAvLyBGb3IgZXhhbXBsZSwgaWYgdGhlIGZvcm1hdHRpbmcgcGF0dGVybiBmb3IgYSBzdHJpbmcgdHlwZSBpcyAnc3RyaW5nJywgd2UnZCBtYWtlIGl0IHZhcmlhZGljIGJ5XG4gICAgLy8gY2hhbmdpbmcgaXQgdG8gJy4uLnN0cmluZ1tdJyBpbiBUeXBlc2NyaXB0IC0gZWFjaCBsYW5ndWFnZSBoYXMgaXRzIG93biB2YXJpYWRpYyBzeW50YXggd2hpY2ggaXMgZGVmaW5lZFxuICAgIC8vIGluIHRoZSBgdmFyaWFkaWNPZigpYCBmdW5jdGlvbi5cbiAgICAvL1xuICAgIC8vIEFub3RoZXIgZXhhbXBsZTogbGV0J3Mgc2F5IHdlIGhhdmUgYSBQeXRob24gZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHNpbmdsZSBudW1iZXIgcGFyYW1ldGVyIGxpa2Ugc286ICdudW1iZXI6IGludCdcbiAgICAvLyBUbyBtYWtlIHRoaXMgdmFyaWFkaWMsIHdlJ2QgY2hhbmdlIGl0IHRvICcqbnVtYmVyOiBpbnQnIC0tIGhlcmUsIHRoZSBmb3JtYXR0aW5nIHBhdHRlcm4gbmVlZHMgdG8gYmUgdXBkYXRlZCB0byBwcmVwZW5kXG4gICAgLy8gdGhlICcqJyBjaGFyYWN0ZXIgdG8gaW5kaWNhdGUgdGhlIHBhcmFtZXRlciBpcyB2YXJpYWRpYy5cbiAgICBpZiAodGhpcy50cmFuc3BpbGVkUGFyYW0udmFyaWFkaWMpIHtcbiAgICAgIHR5cGVzY2hlbWEgPSB7XG4gICAgICAgIGZvcm1hdHRpbmdQYXR0ZXJuOiB0aGlzLnRyYW5zcGlsZS52YXJpYWRpY09mKHR5cGVzY2hlbWEuZm9ybWF0dGluZ1BhdHRlcm4pLFxuICAgICAgICB0eXBlczogdHlwZXNjaGVtYS50eXBlcyxcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGlzSW5pdGlhbGl6ZXIgPSB0aGlzLnBhcmFtZXRlci5tZXRob2Qua2luZCA9PT0gcmVmbGVjdC5NZW1iZXJLaW5kLkluaXRpYWxpemVyO1xuICAgIGNvbnN0IG1ldGhvZE5hbWUgPSBpc0luaXRpYWxpemVyID8gJ0luaXRpYWxpemVyJyA6IHRoaXMudHJhbnNwaWxlZENhbGxhYmxlLm5hbWU7XG4gICAgY29uc3QgbWV0aG9kSWQgPSBpc0luaXRpYWxpemVyID8gJ0luaXRpYWxpemVyJyA6IHRoaXMucGFyYW1ldGVyLm1ldGhvZC5uYW1lO1xuICAgIHJldHVybiB7XG4gICAgICBmcW46IGAke3RoaXMudHJhbnNwaWxlZFBhcmFtLnBhcmVudFR5cGUuZnFufS4ke21ldGhvZE5hbWV9LnBhcmFtZXRlci4ke3RoaXMudHJhbnNwaWxlZFBhcmFtLm5hbWV9YCxcbiAgICAgIGRpc3BsYXlOYW1lOiB0aGlzLnRyYW5zcGlsZWRQYXJhbS5uYW1lLFxuICAgICAgaWQ6IGAke3RoaXMucGFyYW1ldGVyLnBhcmVudFR5cGUuZnFufS4ke21ldGhvZElkfS5wYXJhbWV0ZXIuJHt0aGlzLnBhcmFtZXRlci5uYW1lfWAsXG4gICAgICBvcHRpb25hbDogdGhpcy50cmFuc3BpbGVkUGFyYW0ub3B0aW9uYWwgPT09IHRydWUgPyB0cnVlIDogdW5kZWZpbmVkLCAvLyB0byBzYXZlIHNwYWNlXG4gICAgICBkZWZhdWx0OiB0aGlzLnBhcmFtZXRlci5zcGVjLmRvY3M/LmRlZmF1bHQsXG4gICAgICB0eXBlOiB0eXBlc2NoZW1hLFxuICAgICAgdmFyaWFkaWM6IHRoaXMudHJhbnNwaWxlZFBhcmFtLnZhcmlhZGljLFxuICAgICAgZG9jczogZXh0cmFjdERvY3ModGhpcy5wYXJhbWV0ZXIuZG9jcyksXG4gICAgfTtcbiAgfVxufVxuIl19