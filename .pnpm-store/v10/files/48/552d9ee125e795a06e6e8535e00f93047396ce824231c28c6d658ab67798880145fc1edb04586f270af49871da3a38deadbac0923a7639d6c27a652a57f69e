"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.PythonTranspile = void 0;
const Case = __importStar(require("case"));
const reflect = __importStar(require("jsii-reflect"));
const transpile = __importStar(require("./transpile"));
const errors_1 = require("../../errors");
const schema_1 = require("../schema");
// Helpers
const toSnakeCase = (text) => {
    return Case.snake(text !== null && text !== void 0 ? text : '');
};
const formatImport = (type) => {
    if (type.submodule) {
        return `from ${type.module} import ${type.submodule}`;
    }
    return `import ${type.module}`;
};
const formatArguments = (inputs) => {
    return inputs.length === 0 ? '()' : [
        '(',
        inputs.map(i => `  ${i}`).join(',\n'),
        ')',
    ].join('\n');
};
const formatInvocation = (type, inputs, method) => {
    let target;
    if (type.submodule) {
        if (!type.namespace) {
            throw new Error(`Invalid type: ${type.fqn}: Types defined in a submodule (${type.submodule}) must have a namespace. `);
        }
        // we don't include the submodule name here since it is
        // included in the namespace. this works because we import the submodule
        // in this case.
        // TODO - merge `formatInvocation` with `formatImport` since they are inherently coupled.
        target = `${type.namespace}.${type.name}`;
    }
    else {
        target = type.fqn;
    }
    if (method) {
        target = `${target}.${method}`;
    }
    return `${target}${formatArguments(inputs)}`;
};
const formatSignature = (name, inputs, returns) => {
    const def = 'def ';
    return `${def}${name}${formatArguments(inputs)} -> ${returns || 'None'}`;
};
/**
 * Hack to convert a jsii property to a parameter for
 * python specific parameter expansion.
 */
const propertyToParameter = (callable, property) => {
    return {
        docs: property.docs,
        method: callable,
        name: property.name,
        optional: property.optional,
        parentType: callable.parentType,
        spec: property.spec,
        system: property.system,
        type: property.type,
        variadic: false,
    };
};
/**
 * A python transpiler.
 */
class PythonTranspile extends transpile.TranspileBase {
    constructor() {
        super(transpile.Language.PYTHON);
    }
    readme(readme) {
        return readme;
    }
    unionOf(types) {
        return `${this.typing('Union')}[${types.join(', ')}]`;
    }
    listOf(type) {
        return `${this.typing('List')}[${type}]`;
    }
    variadicOf(type) {
        return `*${type}`;
    }
    mapOf(type) {
        return `${this.typing('Mapping')}[${type}]`;
    }
    any() {
        return this.typing('Any');
    }
    void() {
        return 'None';
    }
    boolean() {
        return 'bool';
    }
    str() {
        return 'str';
    }
    number() {
        return `${this.typing('Union')}[int, float]`;
    }
    date() {
        return 'datetime.datetime';
    }
    enum(enu) {
        return {
            fqn: this.type(enu).fqn,
            name: enu.name,
        };
    }
    enumMember(em) {
        return {
            fqn: `${this.enum(em.enumType).fqn}.${em.name}`,
            name: em.name,
        };
    }
    json() {
        return 'any';
    }
    property(property) {
        const name = property.const ? property.name : toSnakeCase(property.name);
        const typeRef = this.typeReference(property.type);
        return {
            name,
            parentType: this.type(property.parentType),
            typeReference: typeRef,
            optional: property.optional,
            declaration: this.formatProperty(name, typeRef),
        };
    }
    class(klass) {
        return {
            name: klass.name,
            type: this.type(klass),
        };
    }
    parameter(parameter) {
        const name = toSnakeCase(parameter.name);
        const typeRef = this.typeReference(parameter.type);
        return {
            name,
            parentType: this.type(parameter.parentType),
            typeReference: typeRef,
            optional: parameter.optional,
            variadic: 'variadic' in parameter ? parameter.variadic : false,
            declaration: this.formatProperty(name, typeRef),
        };
    }
    struct(struct) {
        const type = this.type(struct);
        const inputs = struct.allProperties.map((p) => this.formatParameters(this.parameter(p)));
        return {
            type: type,
            name: struct.name,
            import: formatImport(type),
            initialization: formatInvocation(type, inputs),
        };
    }
    callable(callable) {
        const type = this.type(callable.parentType);
        const parameters = new Array();
        for (const p of callable.parameters.sort(this.optionalityCompare)) {
            if (!this.isStruct(p)) {
                parameters.push(p);
            }
            else {
                // struct parameters are expanded to the individual struct properties
                const struct = p.parentType.system.findInterface(p.type.fqn);
                for (const property of struct.allProperties) {
                    const parameter = propertyToParameter(callable, property);
                    parameters.push(parameter);
                }
            }
        }
        const name = toSnakeCase(callable.name);
        const inputs = parameters.map((p) => this.formatParameters(this.parameter(p)));
        let returnType;
        if (reflect.Initializer.isInitializer(callable)) {
            returnType = this.typeReference(callable.parentType.reference);
        }
        else if (reflect.Method.isMethod(callable)) {
            returnType = this.typeReference(callable.returns.type);
        }
        const returns = returnType === null || returnType === void 0 ? void 0 : returnType.toString({
            typeFormatter: (t) => t.name,
        });
        return {
            name,
            parentType: type,
            import: formatImport(type),
            parameters,
            signatures: [formatSignature(name, inputs, returns)],
            invocations: [formatInvocation(type, inputs, callable.kind === reflect.MemberKind.Initializer ? undefined : name)],
        };
    }
    type(type) {
        const submodule = this.findSubmodule(type);
        const moduleLike = this.moduleLike(submodule ? submodule : type.assembly);
        const fqn = [moduleLike.name];
        if (type.namespace) {
            fqn.push(type.namespace);
        }
        fqn.push(type.name);
        return new transpile.TranspiledType({
            fqn: fqn.join('.'),
            name: type.name,
            namespace: type.namespace,
            module: moduleLike.name,
            submodule: moduleLike.submodule,
            submodulePath: (0, schema_1.submodulePath)(submodule),
            source: type,
            language: this.language,
        });
    }
    moduleLike(moduleLike) {
        var _a, _b, _c, _d;
        const pythonModule = (_b = (_a = moduleLike.targets) === null || _a === void 0 ? void 0 : _a.python) === null || _b === void 0 ? void 0 : _b.module;
        if (moduleLike instanceof reflect.Submodule) {
            const assembly = this.getParentModule(moduleLike);
            const parentPythonModule = (_d = (_c = assembly.targets) === null || _c === void 0 ? void 0 : _c.python) === null || _d === void 0 ? void 0 : _d.module;
            // if the submodule does not explicitly defines the python module name, then
            // append a snake case version of the submodule name to the parent module name
            // see https://github.com/aws/jsii/blob/b329670bf9ec222fad5fc0d614dcddd5daca7af5/packages/jsii-pacmak/lib/targets/python/type-name.ts#L455
            const submodulePythonModule = pythonModule !== null && pythonModule !== void 0 ? pythonModule : `${parentPythonModule}.${Case.snake(moduleLike.name)}`;
            const moduleParts = submodulePythonModule.split('.');
            return { name: moduleParts[0], submodule: moduleParts[1] };
        }
        if (!pythonModule) {
            throw new errors_1.LanguageNotSupportedError(`Python is not a supported target for module: ${moduleLike.fqn}`);
        }
        return { name: pythonModule };
    }
    interface(iface) {
        return {
            name: iface.name,
            type: this.type(iface),
        };
    }
    isStruct(p) {
        return p.type.fqn ? p.system.findFqn(p.type.fqn).isDataType() : false;
    }
    typing(type) {
        return `typing.${type}`;
    }
    formatParameters(transpiled) {
        const tf = transpiled.typeReference.toString({
            typeFormatter: (t) => t.name,
        });
        if (transpiled.variadic) {
            return `${transpiled.name}: ${this.variadicOf(tf)}`;
        }
        return `${transpiled.name}: ${tf}${transpiled.optional ? ' = None' : ''}`;
    }
    formatProperty(name, typeReference) {
        const tf = typeReference.toString({
            typeFormatter: (t) => t.name,
        });
        return `${name}: ${tf}`;
    }
}
exports.PythonTranspile = PythonTranspile;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHl0aG9uLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2RvY2dlbi90cmFuc3BpbGUvcHl0aG9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDJDQUE2QjtBQUM3QixzREFBd0M7QUFDeEMsdURBQXlDO0FBQ3pDLHlDQUF5RDtBQUN6RCxzQ0FBMEM7QUFFMUMsVUFBVTtBQUNWLE1BQU0sV0FBVyxHQUFHLENBQUMsSUFBYSxFQUFFLEVBQUU7SUFDcEMsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksYUFBSixJQUFJLGNBQUosSUFBSSxHQUFJLEVBQUUsQ0FBQyxDQUFDO0FBQ2hDLENBQUMsQ0FBQztBQUVGLE1BQU0sWUFBWSxHQUFHLENBQUMsSUFBOEIsRUFBRSxFQUFFO0lBQ3RELElBQUksSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDO1FBQ25CLE9BQU8sUUFBUSxJQUFJLENBQUMsTUFBTSxXQUFXLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQztJQUN4RCxDQUFDO0lBQ0QsT0FBTyxVQUFVLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztBQUNqQyxDQUFDLENBQUM7QUFFRixNQUFNLGVBQWUsR0FBRyxDQUFDLE1BQWdCLEVBQUUsRUFBRTtJQUMzQyxPQUFPLE1BQU0sQ0FBQyxNQUFNLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBQ2xDLEdBQUc7UUFDSCxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUM7UUFDckMsR0FBRztLQUNKLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ2YsQ0FBQyxDQUFDO0FBRUYsTUFBTSxnQkFBZ0IsR0FBRyxDQUN2QixJQUE4QixFQUM5QixNQUFnQixFQUNoQixNQUFlLEVBQ2YsRUFBRTtJQUNGLElBQUksTUFBTSxDQUFDO0lBQ1gsSUFBSSxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7UUFDbkIsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQztZQUNwQixNQUFNLElBQUksS0FBSyxDQUNiLGlCQUFpQixJQUFJLENBQUMsR0FBRyxtQ0FBbUMsSUFBSSxDQUFDLFNBQVMsMkJBQTJCLENBQ3RHLENBQUM7UUFDSixDQUFDO1FBQ0QsdURBQXVEO1FBQ3ZELHdFQUF3RTtRQUN4RSxnQkFBZ0I7UUFDaEIseUZBQXlGO1FBQ3pGLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxTQUFTLElBQUksSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO0lBQzVDLENBQUM7U0FBTSxDQUFDO1FBQ04sTUFBTSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUM7SUFDcEIsQ0FBQztJQUVELElBQUksTUFBTSxFQUFFLENBQUM7UUFDWCxNQUFNLEdBQUcsR0FBRyxNQUFNLElBQUksTUFBTSxFQUFFLENBQUM7SUFDakMsQ0FBQztJQUNELE9BQU8sR0FBRyxNQUFNLEdBQUcsZUFBZSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUM7QUFDL0MsQ0FBQyxDQUFDO0FBRUYsTUFBTSxlQUFlLEdBQUcsQ0FBQyxJQUFZLEVBQUUsTUFBZ0IsRUFBRSxPQUFnQixFQUFFLEVBQUU7SUFDM0UsTUFBTSxHQUFHLEdBQUcsTUFBTSxDQUFDO0lBQ25CLE9BQU8sR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLGVBQWUsQ0FBQyxNQUFNLENBQUMsT0FBTyxPQUFPLElBQUksTUFBTSxFQUFFLENBQUM7QUFDM0UsQ0FBQyxDQUFDO0FBRUY7OztHQUdHO0FBQ0gsTUFBTSxtQkFBbUIsR0FBRyxDQUMxQixRQUEwQixFQUMxQixRQUEwQixFQUNQLEVBQUU7SUFDckIsT0FBTztRQUNMLElBQUksRUFBRSxRQUFRLENBQUMsSUFBSTtRQUNuQixNQUFNLEVBQUUsUUFBUTtRQUNoQixJQUFJLEVBQUUsUUFBUSxDQUFDLElBQUk7UUFDbkIsUUFBUSxFQUFFLFFBQVEsQ0FBQyxRQUFRO1FBQzNCLFVBQVUsRUFBRSxRQUFRLENBQUMsVUFBVTtRQUMvQixJQUFJLEVBQUUsUUFBUSxDQUFDLElBQUk7UUFDbkIsTUFBTSxFQUFFLFFBQVEsQ0FBQyxNQUFNO1FBQ3ZCLElBQUksRUFBRSxRQUFRLENBQUMsSUFBSTtRQUNuQixRQUFRLEVBQUUsS0FBSztLQUNoQixDQUFDO0FBQ0osQ0FBQyxDQUFDO0FBRUY7O0dBRUc7QUFDSCxNQUFhLGVBQWdCLFNBQVEsU0FBUyxDQUFDLGFBQWE7SUFDMUQ7UUFDRSxLQUFLLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNuQyxDQUFDO0lBRU0sTUFBTSxDQUFDLE1BQWM7UUFDMUIsT0FBTyxNQUFNLENBQUM7SUFDaEIsQ0FBQztJQUVNLE9BQU8sQ0FBQyxLQUFlO1FBQzVCLE9BQU8sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxJQUFJLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQztJQUN4RCxDQUFDO0lBRU0sTUFBTSxDQUFDLElBQVk7UUFDeEIsT0FBTyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksSUFBSSxHQUFHLENBQUM7SUFDM0MsQ0FBQztJQUVNLFVBQVUsQ0FBQyxJQUFZO1FBQzVCLE9BQU8sSUFBSSxJQUFJLEVBQUUsQ0FBQztJQUNwQixDQUFDO0lBRU0sS0FBSyxDQUFDLElBQVk7UUFDdkIsT0FBTyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLElBQUksSUFBSSxHQUFHLENBQUM7SUFDOUMsQ0FBQztJQUVNLEdBQUc7UUFDUixPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDNUIsQ0FBQztJQUVNLElBQUk7UUFDVCxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDO0lBRU0sT0FBTztRQUNaLE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7SUFFTSxHQUFHO1FBQ1IsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBRU0sTUFBTTtRQUNYLE9BQU8sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxjQUFjLENBQUM7SUFDL0MsQ0FBQztJQUVNLElBQUk7UUFDVCxPQUFPLG1CQUFtQixDQUFDO0lBQzdCLENBQUM7SUFFTSxJQUFJLENBQUMsR0FBcUI7UUFDL0IsT0FBTztZQUNMLEdBQUcsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUc7WUFDdkIsSUFBSSxFQUFFLEdBQUcsQ0FBQyxJQUFJO1NBQ2YsQ0FBQztJQUNKLENBQUM7SUFFTSxVQUFVLENBQUMsRUFBc0I7UUFDdEMsT0FBTztZQUNMLEdBQUcsRUFBRSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsSUFBSSxFQUFFLENBQUMsSUFBSSxFQUFFO1lBQy9DLElBQUksRUFBRSxFQUFFLENBQUMsSUFBSTtTQUNkLENBQUM7SUFDSixDQUFDO0lBQ00sSUFBSTtRQUNULE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQUVNLFFBQVEsQ0FBQyxRQUEwQjtRQUN4QyxNQUFNLElBQUksR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3pFLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ2xELE9BQU87WUFDTCxJQUFJO1lBQ0osVUFBVSxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQztZQUMxQyxhQUFhLEVBQUUsT0FBTztZQUN0QixRQUFRLEVBQUUsUUFBUSxDQUFDLFFBQVE7WUFDM0IsV0FBVyxFQUFFLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQztTQUNoRCxDQUFDO0lBQ0osQ0FBQztJQUVNLEtBQUssQ0FBQyxLQUF3QjtRQUNuQyxPQUFPO1lBQ0wsSUFBSSxFQUFFLEtBQUssQ0FBQyxJQUFJO1lBQ2hCLElBQUksRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQztTQUN2QixDQUFDO0lBQ0osQ0FBQztJQUVNLFNBQVMsQ0FDZCxTQUErQztRQUcvQyxNQUFNLElBQUksR0FBRyxXQUFXLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3pDLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ25ELE9BQU87WUFDTCxJQUFJO1lBQ0osVUFBVSxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBQztZQUMzQyxhQUFhLEVBQUUsT0FBTztZQUN0QixRQUFRLEVBQUUsU0FBUyxDQUFDLFFBQVE7WUFDNUIsUUFBUSxFQUFFLFVBQVUsSUFBSSxTQUFTLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEtBQUs7WUFDOUQsV0FBVyxFQUFFLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQztTQUNoRCxDQUFDO0lBQ0osQ0FBQztJQUVNLE1BQU0sQ0FBQyxNQUE2QjtRQUN6QyxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQy9CLE1BQU0sTUFBTSxHQUFHLE1BQU0sQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FDNUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FDekMsQ0FBQztRQUNGLE9BQU87WUFDTCxJQUFJLEVBQUUsSUFBSTtZQUNWLElBQUksRUFBRSxNQUFNLENBQUMsSUFBSTtZQUNqQixNQUFNLEVBQUUsWUFBWSxDQUFDLElBQUksQ0FBQztZQUMxQixjQUFjLEVBQUUsZ0JBQWdCLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQztTQUMvQyxDQUFDO0lBQ0osQ0FBQztJQUVNLFFBQVEsQ0FBQyxRQUEwQjtRQUN4QyxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUU1QyxNQUFNLFVBQVUsR0FBRyxJQUFJLEtBQUssRUFBcUIsQ0FBQztRQUVsRCxLQUFLLE1BQU0sQ0FBQyxJQUFJLFFBQVEsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxFQUFFLENBQUM7WUFDbEUsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztnQkFDdEIsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNyQixDQUFDO2lCQUFNLENBQUM7Z0JBQ04scUVBQXFFO2dCQUNyRSxNQUFNLE1BQU0sR0FBRyxDQUFDLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFJLENBQUMsQ0FBQztnQkFDOUQsS0FBSyxNQUFNLFFBQVEsSUFBSSxNQUFNLENBQUMsYUFBYSxFQUFFLENBQUM7b0JBQzVDLE1BQU0sU0FBUyxHQUFHLG1CQUFtQixDQUFDLFFBQVEsRUFBRSxRQUFRLENBQUMsQ0FBQztvQkFDMUQsVUFBVSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztnQkFDN0IsQ0FBQztZQUNILENBQUM7UUFDSCxDQUFDO1FBRUQsTUFBTSxJQUFJLEdBQUcsV0FBVyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN4QyxNQUFNLE1BQU0sR0FBRyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFFL0UsSUFBSSxVQUF5RCxDQUFDO1FBQzlELElBQUksT0FBTyxDQUFDLFdBQVcsQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQztZQUNoRCxVQUFVLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ2pFLENBQUM7YUFBTSxJQUFJLE9BQU8sQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUM7WUFDN0MsVUFBVSxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN6RCxDQUFDO1FBQ0QsTUFBTSxPQUFPLEdBQUcsVUFBVSxhQUFWLFVBQVUsdUJBQVYsVUFBVSxDQUFFLFFBQVEsQ0FBQztZQUNuQyxhQUFhLEVBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJO1NBQzdCLENBQUMsQ0FBQztRQUVILE9BQU87WUFDTCxJQUFJO1lBQ0osVUFBVSxFQUFFLElBQUk7WUFDaEIsTUFBTSxFQUFFLFlBQVksQ0FBQyxJQUFJLENBQUM7WUFDMUIsVUFBVTtZQUNWLFVBQVUsRUFBRSxDQUFDLGVBQWUsQ0FBQyxJQUFJLEVBQUUsTUFBTSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1lBQ3BELFdBQVcsRUFBRSxDQUFDLGdCQUFnQixDQUM1QixJQUFJLEVBQ0osTUFBTSxFQUNOLFFBQVEsQ0FBQyxJQUFJLEtBQUssT0FBTyxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUNwRSxDQUFDO1NBQ0gsQ0FBQztJQUNKLENBQUM7SUFFTSxJQUFJLENBQUMsSUFBa0I7UUFDNUIsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUMzQyxNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7UUFFMUUsTUFBTSxHQUFHLEdBQUcsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFOUIsSUFBSSxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7WUFDbkIsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDM0IsQ0FBQztRQUNELEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBRXBCLE9BQU8sSUFBSSxTQUFTLENBQUMsY0FBYyxDQUFDO1lBQ2xDLEdBQUcsRUFBRSxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQztZQUNsQixJQUFJLEVBQUUsSUFBSSxDQUFDLElBQUk7WUFDZixTQUFTLEVBQUUsSUFBSSxDQUFDLFNBQVM7WUFDekIsTUFBTSxFQUFFLFVBQVUsQ0FBQyxJQUFJO1lBQ3ZCLFNBQVMsRUFBRSxVQUFVLENBQUMsU0FBUztZQUMvQixhQUFhLEVBQUUsSUFBQSxzQkFBYSxFQUFDLFNBQVMsQ0FBQztZQUN2QyxNQUFNLEVBQUUsSUFBSTtZQUNaLFFBQVEsRUFBRSxJQUFJLENBQUMsUUFBUTtTQUN4QixDQUFDLENBQUM7SUFDTCxDQUFDO0lBRU0sVUFBVSxDQUNmLFVBQThCOztRQUU5QixNQUFNLFlBQVksR0FBRyxNQUFBLE1BQUEsVUFBVSxDQUFDLE9BQU8sMENBQUUsTUFBTSwwQ0FBRSxNQUFNLENBQUM7UUFFeEQsSUFBSSxVQUFVLFlBQVksT0FBTyxDQUFDLFNBQVMsRUFBRSxDQUFDO1lBQzVDLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUMsVUFBVSxDQUFDLENBQUM7WUFDbEQsTUFBTSxrQkFBa0IsR0FBRyxNQUFBLE1BQUEsUUFBUSxDQUFDLE9BQU8sMENBQUUsTUFBTSwwQ0FBRSxNQUFNLENBQUM7WUFFNUQsNEVBQTRFO1lBQzVFLDhFQUE4RTtZQUM5RSwwSUFBMEk7WUFDMUksTUFBTSxxQkFBcUIsR0FBRyxZQUFZLGFBQVosWUFBWSxjQUFaLFlBQVksR0FBSSxHQUFHLGtCQUFrQixJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUM7WUFFckcsTUFBTSxXQUFXLEdBQUcscUJBQXFCLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQ3JELE9BQU8sRUFBRSxJQUFJLEVBQUUsV0FBVyxDQUFDLENBQUMsQ0FBQyxFQUFFLFNBQVMsRUFBRSxXQUFXLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztRQUM3RCxDQUFDO1FBRUQsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO1lBQ2xCLE1BQU0sSUFBSSxrQ0FBeUIsQ0FDakMsZ0RBQWdELFVBQVUsQ0FBQyxHQUFHLEVBQUUsQ0FDakUsQ0FBQztRQUNKLENBQUM7UUFFRCxPQUFPLEVBQUUsSUFBSSxFQUFFLFlBQVksRUFBRSxDQUFDO0lBQ2hDLENBQUM7SUFFTSxTQUFTLENBQ2QsS0FBNEI7UUFFNUIsT0FBTztZQUNMLElBQUksRUFBRSxLQUFLLENBQUMsSUFBSTtZQUNoQixJQUFJLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUM7U0FDdkIsQ0FBQztJQUNKLENBQUM7SUFFTyxRQUFRLENBQUMsQ0FBb0I7UUFDbkMsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDO0lBQ3hFLENBQUM7SUFFTyxNQUFNLENBQUMsSUFBMEM7UUFDdkQsT0FBTyxVQUFVLElBQUksRUFBRSxDQUFDO0lBQzFCLENBQUM7SUFFTyxnQkFBZ0IsQ0FDdEIsVUFBeUM7UUFFekMsTUFBTSxFQUFFLEdBQUcsVUFBVSxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUM7WUFDM0MsYUFBYSxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSTtTQUM3QixDQUFDLENBQUM7UUFFSCxJQUFJLFVBQVUsQ0FBQyxRQUFRLEVBQUUsQ0FBQztZQUN4QixPQUFPLEdBQUcsVUFBVSxDQUFDLElBQUksS0FBSyxJQUFJLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7UUFDdEQsQ0FBQztRQUVELE9BQU8sR0FBRyxVQUFVLENBQUMsSUFBSSxLQUFLLEVBQUUsR0FBRyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDO0lBQzVFLENBQUM7SUFFTyxjQUFjLENBQ3BCLElBQVksRUFDWixhQUFnRDtRQUVoRCxNQUFNLEVBQUUsR0FBRyxhQUFhLENBQUMsUUFBUSxDQUFDO1lBQ2hDLGFBQWEsRUFBRSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUk7U0FDN0IsQ0FBQyxDQUFDO1FBQ0gsT0FBTyxHQUFHLElBQUksS0FBSyxFQUFFLEVBQUUsQ0FBQztJQUMxQixDQUFDO0NBQ0Y7QUF6UEQsMENBeVBDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQ2FzZSBmcm9tICdjYXNlJztcbmltcG9ydCAqIGFzIHJlZmxlY3QgZnJvbSAnanNpaS1yZWZsZWN0JztcbmltcG9ydCAqIGFzIHRyYW5zcGlsZSBmcm9tICcuL3RyYW5zcGlsZSc7XG5pbXBvcnQgeyBMYW5ndWFnZU5vdFN1cHBvcnRlZEVycm9yIH0gZnJvbSAnLi4vLi4vZXJyb3JzJztcbmltcG9ydCB7IHN1Ym1vZHVsZVBhdGggfSBmcm9tICcuLi9zY2hlbWEnO1xuXG4vLyBIZWxwZXJzXG5jb25zdCB0b1NuYWtlQ2FzZSA9ICh0ZXh0Pzogc3RyaW5nKSA9PiB7XG4gIHJldHVybiBDYXNlLnNuYWtlKHRleHQgPz8gJycpO1xufTtcblxuY29uc3QgZm9ybWF0SW1wb3J0ID0gKHR5cGU6IHRyYW5zcGlsZS5UcmFuc3BpbGVkVHlwZSkgPT4ge1xuICBpZiAodHlwZS5zdWJtb2R1bGUpIHtcbiAgICByZXR1cm4gYGZyb20gJHt0eXBlLm1vZHVsZX0gaW1wb3J0ICR7dHlwZS5zdWJtb2R1bGV9YDtcbiAgfVxuICByZXR1cm4gYGltcG9ydCAke3R5cGUubW9kdWxlfWA7XG59O1xuXG5jb25zdCBmb3JtYXRBcmd1bWVudHMgPSAoaW5wdXRzOiBzdHJpbmdbXSkgPT4ge1xuICByZXR1cm4gaW5wdXRzLmxlbmd0aCA9PT0gMCA/ICcoKScgOiBbXG4gICAgJygnLFxuICAgIGlucHV0cy5tYXAoaSA9PiBgICAke2l9YCkuam9pbignLFxcbicpLFxuICAgICcpJyxcbiAgXS5qb2luKCdcXG4nKTtcbn07XG5cbmNvbnN0IGZvcm1hdEludm9jYXRpb24gPSAoXG4gIHR5cGU6IHRyYW5zcGlsZS5UcmFuc3BpbGVkVHlwZSxcbiAgaW5wdXRzOiBzdHJpbmdbXSxcbiAgbWV0aG9kPzogc3RyaW5nLFxuKSA9PiB7XG4gIGxldCB0YXJnZXQ7XG4gIGlmICh0eXBlLnN1Ym1vZHVsZSkge1xuICAgIGlmICghdHlwZS5uYW1lc3BhY2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEludmFsaWQgdHlwZTogJHt0eXBlLmZxbn06IFR5cGVzIGRlZmluZWQgaW4gYSBzdWJtb2R1bGUgKCR7dHlwZS5zdWJtb2R1bGV9KSBtdXN0IGhhdmUgYSBuYW1lc3BhY2UuIGAsXG4gICAgICApO1xuICAgIH1cbiAgICAvLyB3ZSBkb24ndCBpbmNsdWRlIHRoZSBzdWJtb2R1bGUgbmFtZSBoZXJlIHNpbmNlIGl0IGlzXG4gICAgLy8gaW5jbHVkZWQgaW4gdGhlIG5hbWVzcGFjZS4gdGhpcyB3b3JrcyBiZWNhdXNlIHdlIGltcG9ydCB0aGUgc3VibW9kdWxlXG4gICAgLy8gaW4gdGhpcyBjYXNlLlxuICAgIC8vIFRPRE8gLSBtZXJnZSBgZm9ybWF0SW52b2NhdGlvbmAgd2l0aCBgZm9ybWF0SW1wb3J0YCBzaW5jZSB0aGV5IGFyZSBpbmhlcmVudGx5IGNvdXBsZWQuXG4gICAgdGFyZ2V0ID0gYCR7dHlwZS5uYW1lc3BhY2V9LiR7dHlwZS5uYW1lfWA7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0ID0gdHlwZS5mcW47XG4gIH1cblxuICBpZiAobWV0aG9kKSB7XG4gICAgdGFyZ2V0ID0gYCR7dGFyZ2V0fS4ke21ldGhvZH1gO1xuICB9XG4gIHJldHVybiBgJHt0YXJnZXR9JHtmb3JtYXRBcmd1bWVudHMoaW5wdXRzKX1gO1xufTtcblxuY29uc3QgZm9ybWF0U2lnbmF0dXJlID0gKG5hbWU6IHN0cmluZywgaW5wdXRzOiBzdHJpbmdbXSwgcmV0dXJucz86IHN0cmluZykgPT4ge1xuICBjb25zdCBkZWYgPSAnZGVmICc7XG4gIHJldHVybiBgJHtkZWZ9JHtuYW1lfSR7Zm9ybWF0QXJndW1lbnRzKGlucHV0cyl9IC0+ICR7cmV0dXJucyB8fCAnTm9uZSd9YDtcbn07XG5cbi8qKlxuICogSGFjayB0byBjb252ZXJ0IGEganNpaSBwcm9wZXJ0eSB0byBhIHBhcmFtZXRlciBmb3JcbiAqIHB5dGhvbiBzcGVjaWZpYyBwYXJhbWV0ZXIgZXhwYW5zaW9uLlxuICovXG5jb25zdCBwcm9wZXJ0eVRvUGFyYW1ldGVyID0gKFxuICBjYWxsYWJsZTogcmVmbGVjdC5DYWxsYWJsZSxcbiAgcHJvcGVydHk6IHJlZmxlY3QuUHJvcGVydHksXG4pOiByZWZsZWN0LlBhcmFtZXRlciA9PiB7XG4gIHJldHVybiB7XG4gICAgZG9jczogcHJvcGVydHkuZG9jcyxcbiAgICBtZXRob2Q6IGNhbGxhYmxlLFxuICAgIG5hbWU6IHByb3BlcnR5Lm5hbWUsXG4gICAgb3B0aW9uYWw6IHByb3BlcnR5Lm9wdGlvbmFsLFxuICAgIHBhcmVudFR5cGU6IGNhbGxhYmxlLnBhcmVudFR5cGUsXG4gICAgc3BlYzogcHJvcGVydHkuc3BlYyxcbiAgICBzeXN0ZW06IHByb3BlcnR5LnN5c3RlbSxcbiAgICB0eXBlOiBwcm9wZXJ0eS50eXBlLFxuICAgIHZhcmlhZGljOiBmYWxzZSxcbiAgfTtcbn07XG5cbi8qKlxuICogQSBweXRob24gdHJhbnNwaWxlci5cbiAqL1xuZXhwb3J0IGNsYXNzIFB5dGhvblRyYW5zcGlsZSBleHRlbmRzIHRyYW5zcGlsZS5UcmFuc3BpbGVCYXNlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIodHJhbnNwaWxlLkxhbmd1YWdlLlBZVEhPTik7XG4gIH1cblxuICBwdWJsaWMgcmVhZG1lKHJlYWRtZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gcmVhZG1lO1xuICB9XG5cbiAgcHVibGljIHVuaW9uT2YodHlwZXM6IHN0cmluZ1tdKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYCR7dGhpcy50eXBpbmcoJ1VuaW9uJyl9WyR7dHlwZXMuam9pbignLCAnKX1dYDtcbiAgfVxuXG4gIHB1YmxpYyBsaXN0T2YodHlwZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYCR7dGhpcy50eXBpbmcoJ0xpc3QnKX1bJHt0eXBlfV1gO1xuICB9XG5cbiAgcHVibGljIHZhcmlhZGljT2YodHlwZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYCoke3R5cGV9YDtcbiAgfVxuXG4gIHB1YmxpYyBtYXBPZih0eXBlOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBgJHt0aGlzLnR5cGluZygnTWFwcGluZycpfVske3R5cGV9XWA7XG4gIH1cblxuICBwdWJsaWMgYW55KCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMudHlwaW5nKCdBbnknKTtcbiAgfVxuXG4gIHB1YmxpYyB2b2lkKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICdOb25lJztcbiAgfVxuXG4gIHB1YmxpYyBib29sZWFuKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICdib29sJztcbiAgfVxuXG4gIHB1YmxpYyBzdHIoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ3N0cic7XG4gIH1cblxuICBwdWJsaWMgbnVtYmVyKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGAke3RoaXMudHlwaW5nKCdVbmlvbicpfVtpbnQsIGZsb2F0XWA7XG4gIH1cblxuICBwdWJsaWMgZGF0ZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiAnZGF0ZXRpbWUuZGF0ZXRpbWUnO1xuICB9XG5cbiAgcHVibGljIGVudW0oZW51OiByZWZsZWN0LkVudW1UeXBlKTogdHJhbnNwaWxlLlRyYW5zcGlsZWRFbnVtIHtcbiAgICByZXR1cm4ge1xuICAgICAgZnFuOiB0aGlzLnR5cGUoZW51KS5mcW4sXG4gICAgICBuYW1lOiBlbnUubmFtZSxcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIGVudW1NZW1iZXIoZW06IHJlZmxlY3QuRW51bU1lbWJlcik6IHRyYW5zcGlsZS5UcmFuc3BpbGVkRW51bU1lbWJlciB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZxbjogYCR7dGhpcy5lbnVtKGVtLmVudW1UeXBlKS5mcW59LiR7ZW0ubmFtZX1gLFxuICAgICAgbmFtZTogZW0ubmFtZSxcbiAgICB9O1xuICB9XG4gIHB1YmxpYyBqc29uKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICdhbnknO1xuICB9XG5cbiAgcHVibGljIHByb3BlcnR5KHByb3BlcnR5OiByZWZsZWN0LlByb3BlcnR5KTogdHJhbnNwaWxlLlRyYW5zcGlsZWRQcm9wZXJ0eSB7XG4gICAgY29uc3QgbmFtZSA9IHByb3BlcnR5LmNvbnN0ID8gcHJvcGVydHkubmFtZSA6IHRvU25ha2VDYXNlKHByb3BlcnR5Lm5hbWUpO1xuICAgIGNvbnN0IHR5cGVSZWYgPSB0aGlzLnR5cGVSZWZlcmVuY2UocHJvcGVydHkudHlwZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWUsXG4gICAgICBwYXJlbnRUeXBlOiB0aGlzLnR5cGUocHJvcGVydHkucGFyZW50VHlwZSksXG4gICAgICB0eXBlUmVmZXJlbmNlOiB0eXBlUmVmLFxuICAgICAgb3B0aW9uYWw6IHByb3BlcnR5Lm9wdGlvbmFsLFxuICAgICAgZGVjbGFyYXRpb246IHRoaXMuZm9ybWF0UHJvcGVydHkobmFtZSwgdHlwZVJlZiksXG4gICAgfTtcbiAgfVxuXG4gIHB1YmxpYyBjbGFzcyhrbGFzczogcmVmbGVjdC5DbGFzc1R5cGUpOiB0cmFuc3BpbGUuVHJhbnNwaWxlZENsYXNzIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZToga2xhc3MubmFtZSxcbiAgICAgIHR5cGU6IHRoaXMudHlwZShrbGFzcyksXG4gICAgfTtcbiAgfVxuXG4gIHB1YmxpYyBwYXJhbWV0ZXIoXG4gICAgcGFyYW1ldGVyOiByZWZsZWN0LlBhcmFtZXRlciB8IHJlZmxlY3QuUHJvcGVydHksXG4gICk6IHRyYW5zcGlsZS5UcmFuc3BpbGVkUGFyYW1ldGVyIHtcblxuICAgIGNvbnN0IG5hbWUgPSB0b1NuYWtlQ2FzZShwYXJhbWV0ZXIubmFtZSk7XG4gICAgY29uc3QgdHlwZVJlZiA9IHRoaXMudHlwZVJlZmVyZW5jZShwYXJhbWV0ZXIudHlwZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWUsXG4gICAgICBwYXJlbnRUeXBlOiB0aGlzLnR5cGUocGFyYW1ldGVyLnBhcmVudFR5cGUpLFxuICAgICAgdHlwZVJlZmVyZW5jZTogdHlwZVJlZixcbiAgICAgIG9wdGlvbmFsOiBwYXJhbWV0ZXIub3B0aW9uYWwsXG4gICAgICB2YXJpYWRpYzogJ3ZhcmlhZGljJyBpbiBwYXJhbWV0ZXIgPyBwYXJhbWV0ZXIudmFyaWFkaWMgOiBmYWxzZSxcbiAgICAgIGRlY2xhcmF0aW9uOiB0aGlzLmZvcm1hdFByb3BlcnR5KG5hbWUsIHR5cGVSZWYpLFxuICAgIH07XG4gIH1cblxuICBwdWJsaWMgc3RydWN0KHN0cnVjdDogcmVmbGVjdC5JbnRlcmZhY2VUeXBlKTogdHJhbnNwaWxlLlRyYW5zcGlsZWRTdHJ1Y3Qge1xuICAgIGNvbnN0IHR5cGUgPSB0aGlzLnR5cGUoc3RydWN0KTtcbiAgICBjb25zdCBpbnB1dHMgPSBzdHJ1Y3QuYWxsUHJvcGVydGllcy5tYXAoKHApID0+XG4gICAgICB0aGlzLmZvcm1hdFBhcmFtZXRlcnModGhpcy5wYXJhbWV0ZXIocCkpLFxuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBuYW1lOiBzdHJ1Y3QubmFtZSxcbiAgICAgIGltcG9ydDogZm9ybWF0SW1wb3J0KHR5cGUpLFxuICAgICAgaW5pdGlhbGl6YXRpb246IGZvcm1hdEludm9jYXRpb24odHlwZSwgaW5wdXRzKSxcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIGNhbGxhYmxlKGNhbGxhYmxlOiByZWZsZWN0LkNhbGxhYmxlKTogdHJhbnNwaWxlLlRyYW5zcGlsZWRDYWxsYWJsZSB7XG4gICAgY29uc3QgdHlwZSA9IHRoaXMudHlwZShjYWxsYWJsZS5wYXJlbnRUeXBlKTtcblxuICAgIGNvbnN0IHBhcmFtZXRlcnMgPSBuZXcgQXJyYXk8cmVmbGVjdC5QYXJhbWV0ZXI+KCk7XG5cbiAgICBmb3IgKGNvbnN0IHAgb2YgY2FsbGFibGUucGFyYW1ldGVycy5zb3J0KHRoaXMub3B0aW9uYWxpdHlDb21wYXJlKSkge1xuICAgICAgaWYgKCF0aGlzLmlzU3RydWN0KHApKSB7XG4gICAgICAgIHBhcmFtZXRlcnMucHVzaChwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHN0cnVjdCBwYXJhbWV0ZXJzIGFyZSBleHBhbmRlZCB0byB0aGUgaW5kaXZpZHVhbCBzdHJ1Y3QgcHJvcGVydGllc1xuICAgICAgICBjb25zdCBzdHJ1Y3QgPSBwLnBhcmVudFR5cGUuc3lzdGVtLmZpbmRJbnRlcmZhY2UocC50eXBlLmZxbiEpO1xuICAgICAgICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIHN0cnVjdC5hbGxQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgY29uc3QgcGFyYW1ldGVyID0gcHJvcGVydHlUb1BhcmFtZXRlcihjYWxsYWJsZSwgcHJvcGVydHkpO1xuICAgICAgICAgIHBhcmFtZXRlcnMucHVzaChwYXJhbWV0ZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgbmFtZSA9IHRvU25ha2VDYXNlKGNhbGxhYmxlLm5hbWUpO1xuICAgIGNvbnN0IGlucHV0cyA9IHBhcmFtZXRlcnMubWFwKChwKSA9PiB0aGlzLmZvcm1hdFBhcmFtZXRlcnModGhpcy5wYXJhbWV0ZXIocCkpKTtcblxuICAgIGxldCByZXR1cm5UeXBlOiB0cmFuc3BpbGUuVHJhbnNwaWxlZFR5cGVSZWZlcmVuY2UgfCB1bmRlZmluZWQ7XG4gICAgaWYgKHJlZmxlY3QuSW5pdGlhbGl6ZXIuaXNJbml0aWFsaXplcihjYWxsYWJsZSkpIHtcbiAgICAgIHJldHVyblR5cGUgPSB0aGlzLnR5cGVSZWZlcmVuY2UoY2FsbGFibGUucGFyZW50VHlwZS5yZWZlcmVuY2UpO1xuICAgIH0gZWxzZSBpZiAocmVmbGVjdC5NZXRob2QuaXNNZXRob2QoY2FsbGFibGUpKSB7XG4gICAgICByZXR1cm5UeXBlID0gdGhpcy50eXBlUmVmZXJlbmNlKGNhbGxhYmxlLnJldHVybnMudHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IHJldHVybnMgPSByZXR1cm5UeXBlPy50b1N0cmluZyh7XG4gICAgICB0eXBlRm9ybWF0dGVyOiAodCkgPT4gdC5uYW1lLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWUsXG4gICAgICBwYXJlbnRUeXBlOiB0eXBlLFxuICAgICAgaW1wb3J0OiBmb3JtYXRJbXBvcnQodHlwZSksXG4gICAgICBwYXJhbWV0ZXJzLFxuICAgICAgc2lnbmF0dXJlczogW2Zvcm1hdFNpZ25hdHVyZShuYW1lLCBpbnB1dHMsIHJldHVybnMpXSxcbiAgICAgIGludm9jYXRpb25zOiBbZm9ybWF0SW52b2NhdGlvbihcbiAgICAgICAgdHlwZSxcbiAgICAgICAgaW5wdXRzLFxuICAgICAgICBjYWxsYWJsZS5raW5kID09PSByZWZsZWN0Lk1lbWJlcktpbmQuSW5pdGlhbGl6ZXIgPyB1bmRlZmluZWQgOiBuYW1lLFxuICAgICAgKV0sXG4gICAgfTtcbiAgfVxuXG4gIHB1YmxpYyB0eXBlKHR5cGU6IHJlZmxlY3QuVHlwZSk6IHRyYW5zcGlsZS5UcmFuc3BpbGVkVHlwZSB7XG4gICAgY29uc3Qgc3VibW9kdWxlID0gdGhpcy5maW5kU3VibW9kdWxlKHR5cGUpO1xuICAgIGNvbnN0IG1vZHVsZUxpa2UgPSB0aGlzLm1vZHVsZUxpa2Uoc3VibW9kdWxlID8gc3VibW9kdWxlIDogdHlwZS5hc3NlbWJseSk7XG5cbiAgICBjb25zdCBmcW4gPSBbbW9kdWxlTGlrZS5uYW1lXTtcblxuICAgIGlmICh0eXBlLm5hbWVzcGFjZSkge1xuICAgICAgZnFuLnB1c2godHlwZS5uYW1lc3BhY2UpO1xuICAgIH1cbiAgICBmcW4ucHVzaCh0eXBlLm5hbWUpO1xuXG4gICAgcmV0dXJuIG5ldyB0cmFuc3BpbGUuVHJhbnNwaWxlZFR5cGUoe1xuICAgICAgZnFuOiBmcW4uam9pbignLicpLFxuICAgICAgbmFtZTogdHlwZS5uYW1lLFxuICAgICAgbmFtZXNwYWNlOiB0eXBlLm5hbWVzcGFjZSxcbiAgICAgIG1vZHVsZTogbW9kdWxlTGlrZS5uYW1lLFxuICAgICAgc3VibW9kdWxlOiBtb2R1bGVMaWtlLnN1Ym1vZHVsZSxcbiAgICAgIHN1Ym1vZHVsZVBhdGg6IHN1Ym1vZHVsZVBhdGgoc3VibW9kdWxlKSxcbiAgICAgIHNvdXJjZTogdHlwZSxcbiAgICAgIGxhbmd1YWdlOiB0aGlzLmxhbmd1YWdlLFxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIG1vZHVsZUxpa2UoXG4gICAgbW9kdWxlTGlrZTogcmVmbGVjdC5Nb2R1bGVMaWtlLFxuICApOiB0cmFuc3BpbGUuVHJhbnNwaWxlZE1vZHVsZUxpa2Uge1xuICAgIGNvbnN0IHB5dGhvbk1vZHVsZSA9IG1vZHVsZUxpa2UudGFyZ2V0cz8ucHl0aG9uPy5tb2R1bGU7XG5cbiAgICBpZiAobW9kdWxlTGlrZSBpbnN0YW5jZW9mIHJlZmxlY3QuU3VibW9kdWxlKSB7XG4gICAgICBjb25zdCBhc3NlbWJseSA9IHRoaXMuZ2V0UGFyZW50TW9kdWxlKG1vZHVsZUxpa2UpO1xuICAgICAgY29uc3QgcGFyZW50UHl0aG9uTW9kdWxlID0gYXNzZW1ibHkudGFyZ2V0cz8ucHl0aG9uPy5tb2R1bGU7XG5cbiAgICAgIC8vIGlmIHRoZSBzdWJtb2R1bGUgZG9lcyBub3QgZXhwbGljaXRseSBkZWZpbmVzIHRoZSBweXRob24gbW9kdWxlIG5hbWUsIHRoZW5cbiAgICAgIC8vIGFwcGVuZCBhIHNuYWtlIGNhc2UgdmVyc2lvbiBvZiB0aGUgc3VibW9kdWxlIG5hbWUgdG8gdGhlIHBhcmVudCBtb2R1bGUgbmFtZVxuICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9hd3MvanNpaS9ibG9iL2IzMjk2NzBiZjllYzIyMmZhZDVmYzBkNjE0ZGNkZGQ1ZGFjYTdhZjUvcGFja2FnZXMvanNpaS1wYWNtYWsvbGliL3RhcmdldHMvcHl0aG9uL3R5cGUtbmFtZS50cyNMNDU1XG4gICAgICBjb25zdCBzdWJtb2R1bGVQeXRob25Nb2R1bGUgPSBweXRob25Nb2R1bGUgPz8gYCR7cGFyZW50UHl0aG9uTW9kdWxlfS4ke0Nhc2Uuc25ha2UobW9kdWxlTGlrZS5uYW1lKX1gO1xuXG4gICAgICBjb25zdCBtb2R1bGVQYXJ0cyA9IHN1Ym1vZHVsZVB5dGhvbk1vZHVsZS5zcGxpdCgnLicpO1xuICAgICAgcmV0dXJuIHsgbmFtZTogbW9kdWxlUGFydHNbMF0sIHN1Ym1vZHVsZTogbW9kdWxlUGFydHNbMV0gfTtcbiAgICB9XG5cbiAgICBpZiAoIXB5dGhvbk1vZHVsZSkge1xuICAgICAgdGhyb3cgbmV3IExhbmd1YWdlTm90U3VwcG9ydGVkRXJyb3IoXG4gICAgICAgIGBQeXRob24gaXMgbm90IGEgc3VwcG9ydGVkIHRhcmdldCBmb3IgbW9kdWxlOiAke21vZHVsZUxpa2UuZnFufWAsXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB7IG5hbWU6IHB5dGhvbk1vZHVsZSB9O1xuICB9XG5cbiAgcHVibGljIGludGVyZmFjZShcbiAgICBpZmFjZTogcmVmbGVjdC5JbnRlcmZhY2VUeXBlLFxuICApOiB0cmFuc3BpbGUuVHJhbnNwaWxlZEludGVyZmFjZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IGlmYWNlLm5hbWUsXG4gICAgICB0eXBlOiB0aGlzLnR5cGUoaWZhY2UpLFxuICAgIH07XG4gIH1cblxuICBwcml2YXRlIGlzU3RydWN0KHA6IHJlZmxlY3QuUGFyYW1ldGVyKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHAudHlwZS5mcW4gPyBwLnN5c3RlbS5maW5kRnFuKHAudHlwZS5mcW4pLmlzRGF0YVR5cGUoKSA6IGZhbHNlO1xuICB9XG5cbiAgcHJpdmF0ZSB0eXBpbmcodHlwZTogJ0xpc3QnIHwgJ01hcHBpbmcnIHwgJ0FueScgfCAnVW5pb24nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYHR5cGluZy4ke3R5cGV9YDtcbiAgfVxuXG4gIHByaXZhdGUgZm9ybWF0UGFyYW1ldGVycyhcbiAgICB0cmFuc3BpbGVkOiB0cmFuc3BpbGUuVHJhbnNwaWxlZFBhcmFtZXRlcixcbiAgKTogc3RyaW5nIHtcbiAgICBjb25zdCB0ZiA9IHRyYW5zcGlsZWQudHlwZVJlZmVyZW5jZS50b1N0cmluZyh7XG4gICAgICB0eXBlRm9ybWF0dGVyOiAodCkgPT4gdC5uYW1lLFxuICAgIH0pO1xuXG4gICAgaWYgKHRyYW5zcGlsZWQudmFyaWFkaWMpIHtcbiAgICAgIHJldHVybiBgJHt0cmFuc3BpbGVkLm5hbWV9OiAke3RoaXMudmFyaWFkaWNPZih0Zil9YDtcbiAgICB9XG5cbiAgICByZXR1cm4gYCR7dHJhbnNwaWxlZC5uYW1lfTogJHt0Zn0ke3RyYW5zcGlsZWQub3B0aW9uYWwgPyAnID0gTm9uZScgOiAnJ31gO1xuICB9XG5cbiAgcHJpdmF0ZSBmb3JtYXRQcm9wZXJ0eShcbiAgICBuYW1lOiBzdHJpbmcsXG4gICAgdHlwZVJlZmVyZW5jZTogdHJhbnNwaWxlLlRyYW5zcGlsZWRUeXBlUmVmZXJlbmNlLFxuICApOiBzdHJpbmcge1xuICAgIGNvbnN0IHRmID0gdHlwZVJlZmVyZW5jZS50b1N0cmluZyh7XG4gICAgICB0eXBlRm9ybWF0dGVyOiAodCkgPT4gdC5uYW1lLFxuICAgIH0pO1xuICAgIHJldHVybiBgJHtuYW1lfTogJHt0Zn1gO1xuICB9XG59XG4iXX0=