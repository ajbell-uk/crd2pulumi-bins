"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.main = main;
const fs = __importStar(require("fs/promises"));
const path = __importStar(require("node:path"));
const yargs = __importStar(require("yargs"));
const transpile_1 = require("./docgen/transpile/transpile");
const index_1 = require("./index");
async function generateForLanguage(docs, options) {
    const { format, output } = options;
    // e.g. API.typescript as name
    const splitByLanguage = output.endsWith(`.${options.language.name}`);
    const submoduleSuffix = splitByLanguage ? `${options.language.name}.${format}` : format;
    // Ensure the output path exists
    const outputPath = path.dirname(output);
    await fs.mkdir(outputPath, { recursive: true });
    if (options.splitBySubmodules) {
        if (format !== 'md') {
            throw new Error('split-by-submodule is only supported for markdown');
        }
        const submodules = await docs.listSubmodules();
        for (const submodule of submodules) {
            const content = await docs.toMarkdown({
                ...options,
                submodule: submodule.fqn,
                allSubmodules: false,
                header: { title: `\`${(0, transpile_1.submoduleRelName)(submodule)}\` Submodule`, id: submodule.fqn },
            });
            await fs.writeFile(path.join(outputPath, `${(0, transpile_1.submoduleRelName)(submodule)}.${submoduleSuffix}`), content.render());
        }
        await fs.writeFile(`${output}.${format}`, await (await docs.toIndexMarkdown(submoduleSuffix, options)).render());
    }
    else {
        const content = await (format === 'md' ? docs.toMarkdown(options) : docs.toJson(options));
        await fs.writeFile(`${output}.${format}`, content.render());
    }
}
async function main() {
    const args = await yargs
        .usage('Usage: $0')
        .option('output', { alias: 'o', type: 'string', required: false, desc: 'Output filename, the file type is automatically added. Defaults to API.md if format is markdown (-f md) or API.json if format is JSON (-f json). If more than one language is passed, then the language will be included in the filename e.g. API.typescript.md' })
        .option('format', { alias: 'f', default: 'md', choices: ['md', 'json'], desc: 'Output format, markdown or json' })
        .option('language', { array: true, alias: 'l', default: ['typescript'], choices: transpile_1.Language.values().map(x => x.toString()), desc: 'Output language' })
        .option('package', { alias: 'p', type: 'string', required: false, desc: 'The name@version of an NPM package to document', defaultDescription: 'The package in the current directory' })
        .option('readme', { alias: 'r', type: 'boolean', required: false, desc: 'Include the user defined README.md in the documentation.' })
        .option('submodule', { alias: 's', type: 'string', required: false, desc: 'Generate docs for a specific submodule (or "root")' })
        .option('split-by-submodule', { type: 'boolean', required: false, desc: 'Generate a separate file for each submodule' })
        .example('$0', 'Generate documentation for the current module as a single file (auto-resolves node dependencies)')
        .argv;
    const submodule = args.submodule === 'root' ? undefined : args.submodule;
    const allSubmodules = !args.submodule;
    const readme = args.readme;
    const splitBySubmodules = args['split-by-submodule'];
    const docs = await (args.package
        ? index_1.Documentation.forPackage(args.package)
        : index_1.Documentation.forProject(process.cwd()));
    const options = (lang, output = 'API', includeLanguageInOutputName = false) => {
        const format = args.format === 'md' ? 'md' : 'json';
        // Clean the user provided output of a possible file ending
        let outputFileName = output.endsWith(`.${format}`)
            ? output.slice(0, -(format.length + 1))
            : output;
        // for multi language docs, include the language in the filename
        if (includeLanguageInOutputName) {
            outputFileName = `${outputFileName}.${lang}`;
        }
        return ({
            readme,
            language: transpile_1.Language.fromString(lang),
            submodule,
            allSubmodules,
            splitBySubmodules,
            format,
            output: outputFileName,
        });
    };
    if (args.language.length <= 1) {
        await generateForLanguage(docs, options(args.language[0], args.output));
    }
    else {
        for (const lang of args.language) {
            await generateForLanguage(docs, options(lang, args.output, true));
        }
    }
}
main().catch(e => {
    console.error(e);
    process.exit(1);
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xpLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2NsaS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1EQSxvQkFvREM7QUF2R0QsZ0RBQWtDO0FBQ2xDLGdEQUFrQztBQUNsQyw2Q0FBK0I7QUFDL0IsNERBQTBFO0FBQzFFLG1DQUF3QztBQVl4QyxLQUFLLFVBQVUsbUJBQW1CLENBQUMsSUFBbUIsRUFBRSxPQUF3QjtJQUM5RSxNQUFNLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxHQUFHLE9BQU8sQ0FBQztJQUNuQyw4QkFBOEI7SUFDOUIsTUFBTSxlQUFlLEdBQUcsTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQztJQUNyRSxNQUFNLGVBQWUsR0FBRyxlQUFlLENBQUMsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQyxJQUFJLElBQUksTUFBTSxFQUFFLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQztJQUV4RixnQ0FBZ0M7SUFDaEMsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUN4QyxNQUFNLEVBQUUsQ0FBQyxLQUFLLENBQUMsVUFBVSxFQUFFLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7SUFFaEQsSUFBSSxPQUFPLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztRQUM5QixJQUFJLE1BQU0sS0FBSyxJQUFJLEVBQUUsQ0FBQztZQUNwQixNQUFNLElBQUksS0FBSyxDQUFDLG1EQUFtRCxDQUFDLENBQUM7UUFDdkUsQ0FBQztRQUVELE1BQU0sVUFBVSxHQUFHLE1BQU0sSUFBSSxDQUFDLGNBQWMsRUFBRSxDQUFDO1FBQy9DLEtBQUssTUFBTSxTQUFTLElBQUksVUFBVSxFQUFFLENBQUM7WUFDbkMsTUFBTSxPQUFPLEdBQUcs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QUNoQyxjQUFjLEdBQUcsR0FBRyxjQUFjLElBQUksSUFBSSxFQUFFLENBQUM7UUFDL0MsQ0FBQztRQUVELE9BQU8sQ0FBQztZQUNOLE1BQU07WUFDTixRQUFRLEVBQUUsb0JBQVEsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDO1lBQ25DLFNBQVM7WUFDVCxhQUFhO1lBQ2IsaUJBQWlCO1lBQ2pCLE1BQU07WUFDTixNQUFNLEVBQUUsY0FBYztTQUN2QixDQUFDLENBQUM7SUFDTCxDQUFDLENBQUM7SUFFRixJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxJQUFJLENBQUMsRUFBRSxDQUFDO1FBQzlCLE1BQU0sbUJBQW1CLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0lBQzFFLENBQUM7U0FBTSxDQUFDO1FBQ04sS0FBSyxNQUFNLElBQUksSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7WUFDakMsTUFBTSxtQkFBbUIsQ0FBQyxJQUFJLEVBQUUsT0FBTyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUM7UUFDcEUsQ0FBQztJQUNILENBQUM7QUFDSCxDQUFDO0FBRUQsSUFBSSxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFO0lBQ2YsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNqQixPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ2xCLENBQUMsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMvcHJvbWlzZXMnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdub2RlOnBhdGgnO1xuaW1wb3J0ICogYXMgeWFyZ3MgZnJvbSAneWFyZ3MnO1xuaW1wb3J0IHsgTGFuZ3VhZ2UsIHN1Ym1vZHVsZVJlbE5hbWUgfSBmcm9tICcuL2RvY2dlbi90cmFuc3BpbGUvdHJhbnNwaWxlJztcbmltcG9ydCB7IERvY3VtZW50YXRpb24gfSBmcm9tICcuL2luZGV4JztcblxudHlwZSBHZW5lcmF0ZU9wdGlvbnMgPSB7XG4gIHJlYWRtZT86IGJvb2xlYW47XG4gIGxhbmd1YWdlOiBMYW5ndWFnZTtcbiAgc3VibW9kdWxlPzogc3RyaW5nO1xuICBhbGxTdWJtb2R1bGVzPzogYm9vbGVhbjtcbiAgc3BsaXRCeVN1Ym1vZHVsZXM/OiBib29sZWFuO1xuICBmb3JtYXQ6ICdtZCcgfCAnanNvbic7XG4gIG91dHB1dDogc3RyaW5nO1xufTtcblxuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVGb3JMYW5ndWFnZShkb2NzOiBEb2N1bWVudGF0aW9uLCBvcHRpb25zOiBHZW5lcmF0ZU9wdGlvbnMpIHtcbiAgY29uc3QgeyBmb3JtYXQsIG91dHB1dCB9ID0gb3B0aW9ucztcbiAgLy8gZS5nLiBBUEkudHlwZXNjcmlwdCBhcyBuYW1lXG4gIGNvbnN0IHNwbGl0QnlMYW5ndWFnZSA9IG91dHB1dC5lbmRzV2l0aChgLiR7b3B0aW9ucy5sYW5ndWFnZS5uYW1lfWApO1xuICBjb25zdCBzdWJtb2R1bGVTdWZmaXggPSBzcGxpdEJ5TGFuZ3VhZ2UgPyBgJHtvcHRpb25zLmxhbmd1YWdlLm5hbWV9LiR7Zm9ybWF0fWAgOiBmb3JtYXQ7XG5cbiAgLy8gRW5zdXJlIHRoZSBvdXRwdXQgcGF0aCBleGlzdHNcbiAgY29uc3Qgb3V0cHV0UGF0aCA9IHBhdGguZGlybmFtZShvdXRwdXQpO1xuICBhd2FpdCBmcy5ta2RpcihvdXRwdXRQYXRoLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcblxuICBpZiAob3B0aW9ucy5zcGxpdEJ5U3VibW9kdWxlcykge1xuICAgIGlmIChmb3JtYXQgIT09ICdtZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc3BsaXQtYnktc3VibW9kdWxlIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBtYXJrZG93bicpO1xuICAgIH1cblxuICAgIGNvbnN0IHN1Ym1vZHVsZXMgPSBhd2FpdCBkb2NzLmxpc3RTdWJtb2R1bGVzKCk7XG4gICAgZm9yIChjb25zdCBzdWJtb2R1bGUgb2Ygc3VibW9kdWxlcykge1xuICAgICAgY29uc3QgY29udGVudCA9IGF3YWl0IGRvY3MudG9NYXJrZG93bih7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIHN1Ym1vZHVsZTogc3VibW9kdWxlLmZxbixcbiAgICAgICAgYWxsU3VibW9kdWxlczogZmFsc2UsXG4gICAgICAgIGhlYWRlcjogeyB0aXRsZTogYFxcYCR7c3VibW9kdWxlUmVsTmFtZShzdWJtb2R1bGUpfVxcYCBTdWJtb2R1bGVgLCBpZDogc3VibW9kdWxlLmZxbiB9LFxuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IGZzLndyaXRlRmlsZShwYXRoLmpvaW4ob3V0cHV0UGF0aCwgYCR7c3VibW9kdWxlUmVsTmFtZShzdWJtb2R1bGUpfS4ke3N1Ym1vZHVsZVN1ZmZpeH1gKSwgY29udGVudC5yZW5kZXIoKSk7XG4gICAgfVxuXG4gICAgYXdhaXQgZnMud3JpdGVGaWxlKGAke291dHB1dH0uJHtmb3JtYXR9YCwgYXdhaXQgKGF3YWl0IGRvY3MudG9JbmRleE1hcmtkb3duKHN1Ym1vZHVsZVN1ZmZpeCwgb3B0aW9ucykpLnJlbmRlcigpKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgKGZvcm1hdCA9PT0gJ21kJyA/IGRvY3MudG9NYXJrZG93bihvcHRpb25zKSA6IGRvY3MudG9Kc29uKG9wdGlvbnMpKTtcbiAgICBhd2FpdCBmcy53cml0ZUZpbGUoYCR7b3V0cHV0fS4ke2Zvcm1hdH1gLCBjb250ZW50LnJlbmRlcigpKTtcbiAgfVxufVxuXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBtYWluKCkge1xuICBjb25zdCBhcmdzID0gYXdhaXQgeWFyZ3NcbiAgICAudXNhZ2UoJ1VzYWdlOiAkMCcpXG4gICAgLm9wdGlvbignb3V0cHV0JywgeyBhbGlhczogJ28nLCB0eXBlOiAnc3RyaW5nJywgcmVxdWlyZWQ6IGZhbHNlLCBkZXNjOiAnT3V0cHV0IGZpbGVuYW1lLCB0aGUgZmlsZSB0eXBlIGlzIGF1dG9tYXRpY2FsbHkgYWRkZWQuIERlZmF1bHRzIHRvIEFQSS5tZCBpZiBmb3JtYXQgaXMgbWFya2Rvd24gKC1mIG1kKSBvciBBUEkuanNvbiBpZiBmb3JtYXQgaXMgSlNPTiAoLWYganNvbikuIElmIG1vcmUgdGhhbiBvbmUgbGFuZ3VhZ2UgaXMgcGFzc2VkLCB0aGVuIHRoZSBsYW5ndWFnZSB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSBmaWxlbmFtZSBlLmcuIEFQSS50eXBlc2NyaXB0Lm1kJyB9KVxuICAgIC5vcHRpb24oJ2Zvcm1hdCcsIHsgYWxpYXM6ICdmJywgZGVmYXVsdDogJ21kJywgY2hvaWNlczogWydtZCcsICdqc29uJ10sIGRlc2M6ICdPdXRwdXQgZm9ybWF0LCBtYXJrZG93biBvciBqc29uJyB9KVxuICAgIC5vcHRpb24oJ2xhbmd1YWdlJywgeyBhcnJheTogdHJ1ZSwgYWxpYXM6ICdsJywgZGVmYXVsdDogWyd0eXBlc2NyaXB0J10sIGNob2ljZXM6IExhbmd1YWdlLnZhbHVlcygpLm1hcCh4ID0+IHgudG9TdHJpbmcoKSksIGRlc2M6ICdPdXRwdXQgbGFuZ3VhZ2UnIH0pXG4gICAgLm9wdGlvbigncGFja2FnZScsIHsgYWxpYXM6ICdwJywgdHlwZTogJ3N0cmluZycsIHJlcXVpcmVkOiBmYWxzZSwgZGVzYzogJ1RoZSBuYW1lQHZlcnNpb24gb2YgYW4gTlBNIHBhY2thZ2UgdG8gZG9jdW1lbnQnLCBkZWZhdWx0RGVzY3JpcHRpb246ICdUaGUgcGFja2FnZSBpbiB0aGUgY3VycmVudCBkaXJlY3RvcnknIH0pXG4gICAgLm9wdGlvbigncmVhZG1lJywgeyBhbGlhczogJ3InLCB0eXBlOiAnYm9vbGVhbicsIHJlcXVpcmVkOiBmYWxzZSwgZGVzYzogJ0luY2x1ZGUgdGhlIHVzZXIgZGVmaW5lZCBSRUFETUUubWQgaW4gdGhlIGRvY3VtZW50YXRpb24uJyB9KVxuICAgIC5vcHRpb24oJ3N1Ym1vZHVsZScsIHsgYWxpYXM6ICdzJywgdHlwZTogJ3N0cmluZycsIHJlcXVpcmVkOiBmYWxzZSwgZGVzYzogJ0dlbmVyYXRlIGRvY3MgZm9yIGEgc3BlY2lmaWMgc3VibW9kdWxlIChvciBcInJvb3RcIiknIH0pXG4gICAgLm9wdGlvbignc3BsaXQtYnktc3VibW9kdWxlJywgeyB0eXBlOiAnYm9vbGVhbicsIHJlcXVpcmVkOiBmYWxzZSwgZGVzYzogJ0dlbmVyYXRlIGEgc2VwYXJhdGUgZmlsZSBmb3IgZWFjaCBzdWJtb2R1bGUnIH0pXG4gICAgLmV4YW1wbGUoJyQwJywgJ0dlbmVyYXRlIGRvY3VtZW50YXRpb24gZm9yIHRoZSBjdXJyZW50IG1vZHVsZSBhcyBhIHNpbmdsZSBmaWxlIChhdXRvLXJlc29sdmVzIG5vZGUgZGVwZW5kZW5jaWVzKScpXG4gICAgLmFyZ3Y7XG5cbiAgY29uc3Qgc3VibW9kdWxlID0gYXJncy5zdWJtb2R1bGUgPT09ICdyb290JyA/IHVuZGVmaW5lZCA6IGFyZ3Muc3VibW9kdWxlO1xuICBjb25zdCBhbGxTdWJtb2R1bGVzID0gIWFyZ3Muc3VibW9kdWxlO1xuICBjb25zdCByZWFkbWUgPSBhcmdzLnJlYWRtZTtcbiAgY29uc3Qgc3BsaXRCeVN1Ym1vZHVsZXMgPSBhcmdzWydzcGxpdC1ieS1zdWJtb2R1bGUnXTtcbiAgY29uc3QgZG9jcyA9IGF3YWl0IChhcmdzLnBhY2thZ2VcbiAgICA/IERvY3VtZW50YXRpb24uZm9yUGFja2FnZShhcmdzLnBhY2thZ2UpXG4gICAgOiBEb2N1bWVudGF0aW9uLmZvclByb2plY3QocHJvY2Vzcy5jd2QoKSkpO1xuXG4gIGNvbnN0IG9wdGlvbnMgPSAobGFuZzogc3RyaW5nLCBvdXRwdXQ6IHN0cmluZyA9ICdBUEknLCBpbmNsdWRlTGFuZ3VhZ2VJbk91dHB1dE5hbWUgPSBmYWxzZSk6IEdlbmVyYXRlT3B0aW9ucyA9PiB7XG4gICAgY29uc3QgZm9ybWF0ID0gYXJncy5mb3JtYXQgPT09ICdtZCcgPyAnbWQnIDogJ2pzb24nO1xuXG4gICAgLy8gQ2xlYW4gdGhlIHVzZXIgcHJvdmlkZWQgb3V0cHV0IG9mIGEgcG9zc2libGUgZmlsZSBlbmRpbmdcbiAgICBsZXQgb3V0cHV0RmlsZU5hbWUgPSBvdXRwdXQuZW5kc1dpdGgoYC4ke2Zvcm1hdH1gKVxuICAgICAgPyBvdXRwdXQuc2xpY2UoMCwgLShmb3JtYXQubGVuZ3RoICsgMSkpXG4gICAgICA6IG91dHB1dDtcblxuICAgIC8vIGZvciBtdWx0aSBsYW5ndWFnZSBkb2NzLCBpbmNsdWRlIHRoZSBsYW5ndWFnZSBpbiB0aGUgZmlsZW5hbWVcbiAgICBpZiAoaW5jbHVkZUxhbmd1YWdlSW5PdXRwdXROYW1lKSB7XG4gICAgICBvdXRwdXRGaWxlTmFtZSA9IGAke291dHB1dEZpbGVOYW1lfS4ke2xhbmd9YDtcbiAgICB9XG5cbiAgICByZXR1cm4gKHtcbiAgICAgIHJlYWRtZSxcbiAgICAgIGxhbmd1YWdlOiBMYW5ndWFnZS5mcm9tU3RyaW5nKGxhbmcpLFxuICAgICAgc3VibW9kdWxlLFxuICAgICAgYWxsU3VibW9kdWxlcyxcbiAgICAgIHNwbGl0QnlTdWJtb2R1bGVzLFxuICAgICAgZm9ybWF0LFxuICAgICAgb3V0cHV0OiBvdXRwdXRGaWxlTmFtZSxcbiAgICB9KTtcbiAgfTtcblxuICBpZiAoYXJncy5sYW5ndWFnZS5sZW5ndGggPD0gMSkge1xuICAgIGF3YWl0IGdlbmVyYXRlRm9yTGFuZ3VhZ2UoZG9jcywgb3B0aW9ucyhhcmdzLmxhbmd1YWdlWzBdLCBhcmdzLm91dHB1dCkpO1xuICB9IGVsc2Uge1xuICAgIGZvciAoY29uc3QgbGFuZyBvZiBhcmdzLmxhbmd1YWdlKSB7XG4gICAgICBhd2FpdCBnZW5lcmF0ZUZvckxhbmd1YWdlKGRvY3MsIG9wdGlvbnMobGFuZywgYXJncy5vdXRwdXQsIHRydWUpKTtcbiAgICB9XG4gIH1cbn1cblxubWFpbigpLmNhdGNoKGUgPT4ge1xuICBjb25zb2xlLmVycm9yKGUpO1xuICBwcm9jZXNzLmV4aXQoMSk7XG59KTtcblxuIl19